"""
Домашняя работа
4.2 Парсер HTTP-заголовков

Напишите функцию http_headers_to_json, которая принимает два аргумента:

    путь к файлу с HTTP-заголовками
    путь к файлу с результатами (в формате JSON)

Функция выполняет конвертирование HTTP-заголовков в формат JSON.

Ключами в JSON-объекте становятся имена заголовков, а значениями - значения заголовков.

Так же в JSON попадает дополнительная информация, в зависимости от вида заголовка.

HTTP-заголовки протокола версии 1.0/1.1 делятся на два вида: заголовки запроса и заголовки ответа.

В заголовках запроса первая строка имеет вид:

"Метод URI Протокол/Версия" - GET / HTTP/1.1

В заголовках ответа первая строка имеет вид:

"Протокол/версия Код Сообщение" - HTTP/1.1 200 OK

В версии протокола 2 из первой строки заголовков ответа было убрано сообщение:

"Протокол/версия Код" - HTTP/2 301

Со второй строки и до символов \n\n перечисляются сами заголовки со значениями.

Формат HTTP-заголовков следующий:

    заголовки отделяются друг от друга символом \n (переносом строки)
    имя заголовка и значение заголовка отделяются двоеточием

Если на входе файл с заголовком запроса, то в JSON файле должны быть ключи:

    "method"
    "uri"
    "protocol"

Если на входе файл с заголовком ответа, то в JSON файле должны быть ключи:

    "protocol"
    "status_code"
    "status_message" (отсутствует если HTTP2)

(!) В выходном файле в значении заголовка не должно быть пробелов в начале и в конце строки

Подсказки:

    Заголовки ответа всегда начинаются на "HTTP/", таким образом их легко отличить
     от заголовков запроса
    В значениях заголовков может присутствовать двоеточие
    Входной файл может заканчиваться переносом строки - \n (как в примерах)
    Имена заголовков могут дублироваться. В этом случаи в JSON записывается последнее значение

Требуется реализовать только функцию, решение не должно осуществлять операций ввода-вывода.
"""
import json

def http_headers_to_json(way_to_http, way_to_result):
    """
    парсинг, файлы, жсон
    """
    dict_of_http = {}
    with open(way_to_http) as f_to_pars:

        my_file = f_to_pars.read().split('\n')
        for lines in my_file:
            try:
                list_l = lines.split(':', 1)
                key = list_l[0]
                value = list_l[1].strip(' ')
                dict_of_http[key] = value
            except IndexError:
                list_l = lines.split(' ')
                if list_l[0] == 'HTTP/1.1':
                    dict_of_http = {'protocol': list_l[0],
                                    'status_code': list_l[1],
                                    'status_message': list_l[2]}
                elif list_l[0] == 'HTTP/2':
                    dict_of_http = {'protocol': list_l[0],
                                    'status_code': list_l[1]}
                elif list_l[0] == 'GET':
                    dict_of_http = {'method': list_l[0],
                                    'uri': list_l[1],
                                    'protocol': list_l[2]}
    with open(way_to_result, 'w') as f_to_res:
        json.dump(dict_of_http, f_to_res, indent=4)
#
# http_headers_to_json('headers-1.txt', 'results-1.json')
# http_headers_to_json('headers-2.txt', 'results-2.json')
# http_headers_to_json('headers-3.txt', 'results-3.json')
